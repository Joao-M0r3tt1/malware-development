----- Socket programming ----- 

    - A socket is a communications connection point (endpoint) that you can name and address in a network. Socket programming shows how to use socket APIs to establish communication links between remote and local processes.

    The processes that use a socket can reside on the same system or different systems on different networks. Sockets are useful for both stand-alone and network applications. Sockets allow you to exchange information between processes on the same machine or across a network, distribute work to the most efficient machine, and they easily allow access to centralized data.


    --- How sockets work
        - Sockets are commonly used for client and server interaction. Typical system configuration places the server on one machine, with the clients on other machines. The clients connect to the server, exchange information, and then disconnect.

        A socket has a typical flow of events. In a connection-oriented client-to-server model, the socket on the server process waits for requests from a client. To do this, the server first establishes (binds) an address that clients can use to find the server. When the address is established, the server waits for clients to request a service. The client-to-server data exchange takes place when a client connects to the server through a socket. The server performs the client's request and sends the reply back to the client.

        https://www.ibm.com/docs/en/ssw_ibm_i_75/rzab6/rxab6500.gif


        Note: The socket APIs are located in the communications model between the application layer and the transport layer. The socket APIs are not a layer in the communication model. Socket APIs allow applications to interact with the transport or networking layers of the typical communications model. The arrows in the following figure show the position of a socket, and the communication layer that the socket provides.

        https://www.ibm.com/docs/en/ssw_ibm_i_75/rzab6/rxab6501.gif


        - Typically, a network configuration does not allow connections between a secure internal network and a less secure external network. However, you can enable sockets to communicate with server programs that run on a system outside a firewall (a very secure host).


########################################################################################################################
    --- Server-side workflow in socket programming - 'Kali Linux VM': 
        - Use the following functions
            `socket()` : creates a socket object. (In this case, a TCP socket that uses IPv4 for communication)
            
            `bind()`   : binds a server to a specific port. (In this case, the host will be a 'Kali Linux VM').
                Note: Along with this binding function, a specific structure must be used that binds/configures the server  
            
            `listen()` : listens for incoming connections 
            
            `accept()` : accepts any connection that is coming to the server correctly
            
            `send()`   : send data
            
            `recv()`   : receives data

        These functions are present in the header file: `sys/socket.h`


    --- Client-side workflow in socket programming - 'Windows':
        - Use the following functions
            `socket()`  : creates a socket object. (In this case, a TCP socket that uses IPv4 for communication)
            
            `connect()` : connect to the destination.
                Note: Along with this function, it is necessary to use a structure, where information that configures the connection is defined
            
            `send()`    : send data
            
            `recv()`    : receives data

        Functions use the library: `winsock2`


    - Note: `sys/socket.h` library is used for Linux machines regardless of whether it is client or server. `winsock2` library is used for Windows machines regardless of whether it is client or server.

    - Note: Difference between the `sys/socket.h` and `winsock2` libraries: client and server workflow is still the same in both, but the syntax in the `winsock2` library is a little different